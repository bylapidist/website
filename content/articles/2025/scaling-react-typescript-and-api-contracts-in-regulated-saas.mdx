---
title: "Architecting a Modern Frontend Platform: Scaling React, TypeScript, and API Contracts in Regulated SaaS"
date: 2025-08-19
description: "Why frontend is the backbone of compliance, velocity, and resilience in regulated SaaS."
summary: "A blueprint for building modern frontend platforms that balance scale, compliance, and developer speed."
image: "/opengraph-image"
author:
    name: "Brett Dorrans"
    url: "https://lapidist.net"
tags:
    - frontend
    - architecture
    - SaaS
    - compliance
    - engineering
---

## The Hidden Complexity of Frontend in Regulated SaaS

In regulated SaaS domains like fintech or govtech, the frontend is more than just a pretty interface; it becomes part of the product's legal and engineering backbone. Frontend platforms in these environments silently enforce compliance (through disclaimers, validations, audit logs) and embody critical business rules. A seemingly minor UI tweak can carry outsized risk. For example, one fintech startup removed a passive data-sharing disclaimer during a redesign. Nothing else changed. Yet the absence of that notice caused a failed compliance audit and a delayed launch.[^2] The lesson? Even non-functional UI elements can be legally required in high-regulation workflows. In this context, frontend architecture is strategic: it's not just about delivering features to end-users, but about embedding resilience, trust, and compliance into the product experience from the ground up.[^2]

Senior engineers and CTOs in regulated SaaS recognise that a robust frontend platform is essential for moving fast and staying safe. “Frontend engineering is way more than UI - at its core, it's about building systems that serve human experiences”.[^3] This system-thinking view is crucial when users' actions must comply with strict rules (think KYC identity checks or medical data privacy) and when every UI component might double as a legal contract. In practice, this means our frontend stack must be deliberately architected to handle complexity: strong foundations in React/TypeScript for maintainability, API contracts to ensure data consistency, state management patterns for reliability, and rigorous governance (linting, testing, accessibility) to enforce quality across the board. In the following sections, I'll share how to architect a modern frontend platform that scales - drawing on 15+ years of experience, with the last 5 in building regulated SaaS UIs - and why the effort pays off in developer velocity, compliance, and product success.

## Foundation Layer - React, TypeScript, and Setup Decisions that Matter

At the heart of any modern frontend platform is a solid foundation. In 2025, that foundation is typically React for the UI library and TypeScript for the language - a combination now considered an industry standard for large-scale apps.[^4] It's easy to treat the initial setup as boilerplate, but early technical decisions ripple forward into long-term velocity. Compare it to city planning: if you build narrow roads today, your city will gridlock as it grows; but if you design wide avenues and strong bridges, your city thrives regardless of scale.[^4] In other words, your framework, language, and architectural patterns are the “roads and bridges” of your digital city. A rushed or flimsy foundation can become a bottleneck, whereas a well-thought-out one enables sustained feature development without constantly tripping on tech debt or rework.

TypeScript deserves special mention in laying this foundation. In large frontends, static typing isn't a luxury - it's a linchpin for maintainability and robustness. By catching type mismatches at compile time, TypeScript prevents entire classes of runtime errors and makes the code self-documenting for new engineers.[^5] In my experience, adopting TypeScript has an initial learning curve, but it pays off exponentially as the codebase grows. It provides improved code clarity and safer refactoring, which means we can keep a high development pace without fearing that a small change will break something unseen.[^5] Put simply, TypeScript brings “robustness to JavaScript that elevates its suitability for large-scale projects”,[^6] allowing a team to move fast now and later. The goal is to balance developer velocity with long-term maintainability - choosing conventions and tools that speed up daily work (like good developer experience, fast reloads, etc.) but also prevent accumulation of chaos.

Foundational decisions also include project structure and shared libraries. In multi-team SaaS products, I advocate for an “internal open-source” model: a mono-repo or modular repo where core pieces (design system components, utility functions, API clients) are centralised and reused across features. This avoids siloed code and keeps everyone on the same foundation. For example, AdRoll's Frontend Core team enabled dozens of engineers to collaborate by bundling common UI packages in a monorepo, so teams could share build tools and not reinvent the wheel for each product.[^1] This kind of sharing culture, supported by tooling (e.g. Turborepo or Nx for monorepos), ensures that improvements to the foundation benefit all parts of the application. It also enforces consistency: one design system, one approach to state management, one lint config, etc., rather than each squad rolling their own. Ultimately, a strong React + TypeScript foundation - with intelligent project structure and shared conventions - lets you build features quickly because the underlying infrastructure is sound and standardised. As we'll see, this foundation sets the stage for everything from API integrations to testing and onboarding.

## API-First Contracts - OpenAPI, Orval, Zod, and React Query in Tandem

A modern frontend platform in a regulated environment must treat APIs as first-class contracts. When multiple teams (and possibly external partners) are developing services, a formal API contract ensures everyone speaks the same language. In practice, this often means using OpenAPI (Swagger) to define your backend endpoints, request/response schemas, and authentication methods up front. By having an explicit OpenAPI spec, we create a single source of truth for data models that both frontend and backend agree on - crucial in high-compliance domains where a mismatched field or unexpected null can cause serious issues.

The next step is to integrate that API contract directly into the frontend code using code generation tools. At a KYC fintech, I used Orval (a popular RESTful client generator) to automatically generate a TypeScript API client and React Query hooks from the OpenAPI spec.[^7] With a simple config, Orval can read our `openapi.yaml` and produce a full suite of strongly-typed functions and custom React hooks for each endpoint. For example, given an endpoint `GET /pets/{id}`, Orval will create a `useShowPetById` hook that wraps React Query's `useQuery` under the hood. These generated hooks come with typed response data and even pre-defined query keys for caching, so the frontend team never has to write repetitive boilerplate for data fetching. The result is an end-to-end type-safe API integration: if the backend changes a field type, the frontend build breaks immediately rather than failing at runtime.

Zod can be used alongside OpenAPI/Orval to provide runtime validation of data. In fact, Orval has a mode to generate Zod schemas automatically for your API models.[^8] This means when the frontend receives JSON from an API, we can parse it through the Zod schema to ensure it matches the expected shape, adding a safety net against corrupted or non-conformant data. Zod's advantage is that it offers a TypeScript-first approach - you define a schema once and get both the runtime checker and the TypeScript type out of it, avoiding redundancy.[^9] This is amazing: you can confidently enforce that “the data we got is exactly what our system expects” and quickly flag any deviation.

With a generated client and Zod validation in place, React Query rounds out the picture for data management. React Query is a “robust library for fetching, caching, synchronising, and updating server state”,[^10] and it excels at reducing the glue code around API calls. All server interactions go through React Query hooks (many of them code-generated), which gives us caching, request deduplication, automatic retries, and consistent loading/error state handling for free. This is especially important for large single-page applications where dozens of components might need data.

In summary, an API-first approach using OpenAPI + Orval + Zod + React Query creates a strong contract between frontend and backend, with both build-time guarantees (via TypeScript) and runtime guarantees (via Zod) that data is as expected. This drastically reduces the chance of frontends displaying wrong information - a critical factor in domains like KYC/AML where showing an incorrect status or failing to handle an edge-case could have compliance repercussions. It also speeds up development: engineers can rely on generated hooks and models instead of writing asynchronous calls from scratch, and they get immediate feedback if they misuse an API.

## Governance and Quality - Linting, Formatting, Storybook, Accessibility, CI/CD

As a codebase and team scale, governance and automated quality checks become the scaffolding that holds everything upright. It's not glamorous, but establishing consistency in code style and catching issues early will save countless hours (and avoid painful production incidents). In a regulated SaaS environment, governance is not optional - it's an enabler for both compliance and developer sanity.

First, code style and linting: We ensure every commit is run through linters (ESLint with a robust rule set, including TypeScript-specific rules) and formatters (Prettier for uniform styling). Linters are configured to flag not just trivial matters, but also accessibility issues and potential bugs. For example, ESLint can be extended with plugins to catch common pitfalls in React (like missing useEffect dependencies) and even detect dead code (unused variables, unreachable branches), which keeps the codebase healthy.[^11] We treat lint errors as build errors - nothing deploys with a red squiggly.

Next, Storybook is a central piece of frontend governance. Storybook serves as a living documentation of UI components and a sandbox for developing and testing them in isolation. Every reusable component comes with a Storybook story demonstrating its variants, usage, and edge cases. This has been invaluable in a regulated context for a few reasons: it enforces modularity, and it allows non-engineering stakeholders to review components early. Using Storybook for shared reviews makes it “faster for legal/product/design to review components outside the app”.[^2]

Automated accessibility testing is another quality gate. We integrate tools like `axe-core` and Google Lighthouse into our CI pipelines to catch issues like missing ARIA labels, low contrast, or keyboard navigation failures before they ever hit production. In high-compliance sectors, accessibility is often a legal requirement (e.g. WCAG standards). By running these checks automatically, we ensure new components or pages don't introduce regressions.

Finally, governance extends to design and UX consistency through a well-curated design system. We enforce that product teams can't just invent new UI components on a whim - they should contribute to or use the existing design system. It's akin to treating components “like public APIs with change control and contracts”.[^2]

## Scaling Patterns - State Management, Caching, and Resilience in Large SPAs

As a frontend codebase grows into a large single-page application (SPA) or multi-module app, managing state and ensuring resilience become significant challenges. Without clear patterns, you can end up with tangled state, race conditions, and an app that crumbles when a single API fails. Here we'll discuss patterns that have proven to work in scaling state management, caching, and overall resilience.

State management in modern React has moved away from monolithic Redux stores towards a mix of localised state and specialised hooks. We leverage React's built-in context and hooks for most state needs, reserving external state libraries only for truly global or cross-cutting state. A key principle is to separate server state (data from APIs) from UI state (local component state or ephemeral state like form inputs). Server state is largely handled by React Query as discussed - it gives us caching and automatic updates. For client state, we often use React context with custom hooks to encapsulate specific concerns.

For example:

- A filterable list in a dashboard is managed via a custom `useFilters` hook backed by React context.[^12]
- Persisted preferences are stored using a `usePersistedState` hook tied into localStorage.[^13]
- Forms use React Hook Form with Zod schemas for type-safe validation.[^9] [^14]

Caching and performance patterns go hand-in-hand with state. React Query's caching means we rarely implement our own in-memory caches for API responses. But we do use techniques like memoization and lazy-loading to ensure the app stays performant.

Resilience is also crucial - a robust frontend platform should handle failures gracefully and not lose all functionality when one piece breaks. React Query helps here with its retry mechanism and caching. Combined with error boundaries and thoughtful fallback UI, this ensures the app degrades gracefully instead of catastrophically.

## The Business Case - Compliance, Delivery Speed, and Onboarding Payoffs

Architecting a frontend platform with all these layers of discipline might seem like over-engineering to some - until you consider the business impact. In regulated SaaS especially, a strong frontend architecture yields tangible benefits: it keeps you out of compliance trouble, accelerates development of new features, and makes onboarding new engineers far smoother.

- Compliance and audit readiness are built in.[^2]
- Shared design systems reduce development time by up to 30–40%.[^15]
- API contracts cut rework by eliminating backend/frontend mismatches.
- Coherent platform patterns make onboarding faster.

In sum, the investment in a scalable frontend platform yields dividends in compliance assurance, faster delivery of features, easier onboarding, and less wasteful work.

## Future Outlook - AI-Assisted Tooling and Agentic Workflows on the Horizon

As we look forward, one exciting frontier for frontend platforms is the incorporation of AI-assisted tooling and “agentic” workflows. The idea is that many of the tasks we now handle through manual effort or static scripts could be offloaded to intelligent agents.

- Dead code elimination and unused dependencies are already targeted by tools.[^11]
- AI-assisted code review is becoming mainstream.[^16]
- Redundant components and inconsistent styling can be flagged automatically.
- Accessibility and compliance reviews can extend beyond static rules, with AI simulating user flows.

In my view, the arrival of AI tooling will further elevate the importance of a well-structured frontend platform. Good architecture makes AI more effective, and AI in turn helps maintain that good architecture.

## Conclusion - A Pragmatic Blueprint for Frontend Platforms in 2025

Building a modern frontend platform is an exercise in strategic engineering. Especially in regulated SaaS domains, it's clear that the frontend is not a mere afterthought or “skin” on the real product - it is an integral part of delivering a compliant, resilient, and high-quality service. We've explored how a robust foundation in React and TypeScript sets the stage for scalable development, how API-first contracts ensure our frontends and backends move in lockstep, and how governance tools like linting, Storybook, and CI pipelines enforce quality at every step. We also delved into state management and caching patterns that keep large applications efficient and error-tolerant, and saw why all these technical choices translate directly into business value.

In a nutshell, the blueprint for a modern frontend platform in 2025 looks like this:

1. Start with a strong typed core (TypeScript) and modular architecture.
2. Embrace automation and codegen (AI, OpenAPI, Orval, React Query, Zod).
3. Institute a design system and thorough quality gates (ESLint, Prettier, accessibility checks, Storybook).
4. Use proven state and data-fetching patterns to handle complexity.
5. Foster a culture where the platform is a shared product, not just an implementation detail.

This approach yields a codebase that is easier to onboard into, adapt, and trust in production. Crucially, keep an eye on the horizon - AI-assisted workflows are coming fast, and the best teams will leverage them to uphold, not cut, standards.

Building a modern frontend platform is certainly a lot of work - but in today's environment, it's work that delivers a competitive edge. I strive to build frontends that are sophisticated and reliable, and to treating the UI layer as the critical infrastructure it truly is.

[^1]: How to Run a Front-End Infrastructure Team - NextRoll https://tech.nextroll.com/blog/frontend/2017/08/29/how-to-run-a-front-end-infrastructure-team.html

[^2]: Building Frontend Applications in Fintech: What Developers Must Know About Compliance, Risk, and Restrictions | by Roman Fedytskyi | Jun, 2025 | Medium https://medium.com/@roman_fedyskyi/building-frontend-applications-in-fintech-what-developers-must-know-about-compliance-risk-and-afca8454b437

[^3]: Frontend Isn't Just UI - DEV Community https://dev.to/muhammadahsanmirza/frontend-isnt-just-ui-289d

[^4]: The New Frontier: Why React and TypeScript Matter in 2025 | by Rick Hightower | Jun, 2025 | Medium https://medium.com/@richardhightower/the-new-frontier-why-react-and-typescript-matter-in-2025-bfce03f5d3c9

[^5]: How to Use TypeScript with React: Building a Strong Foundation | by Chirag Dave | Medium https://medium.com/@chirag.dave/how-to-use-typescript-with-react-building-a-strong-foundation-72d87ba8e699

[^6]: The Essential Role of TypeScript in Large-Scale React Projects https://elevator3.com/the-essential-role-of-typescript-in-large-scale-react-projects/

[^7]: React Query | Orval https://orval.dev/guides/react-query

[^8]: Zod | Orval https://orval.dev/guides/zod

[^9]: Learn Zod validation with React Hook Form | Contentful https://www.contentful.com/blog/react-hook-form-validation-zod/

[^10]: React Query for Data Fetching: Explore the Advanced Features https://www.dhiwise.com/post/react-query-a-deep-dive-into-the-advanced-features

[^11]: How do I find and remove the dead code? | Milestone https://mstone.ai/question/find-remove-dead-code/

[^12]: How to Create a Filterable List in React with the Context API | by Sameer Jain | Medium https://jainsameer.medium.com/react-filterable-list-page-7e3bcf7913cc

[^13]: Mastering React's usePersistedState Hook | LabEx https://labex.io/tutorials/react-react-usepersistedstate-hook-38402

[^14]: How to Validate Forms with Zod and React-Hook-Form | FreeCodeCamp https://www.freecodecamp.org/news/react-form-validation-zod-react-hook-form/

[^15]: How a Design System Saves Time and Money | by Liana Ghazaryan https://www.designsystemscollective.com/how-a-design-system-saves-time-and-money-fdef6280042e

[^16]: AI Code Review and the Best AI Code Review Tools in 2025 - Qodo https://www.qodo.ai/blog/ai-code-review/
